---
title: "Semana 29: Instalación de Robotics Academy en Docker y control PID para seguir líneas"
excerpt_separator: "<!--more-->"
categories:
  - Blog
tags:
  - Robotics Academy
  - Docker
  - Control PID
---

## Instalación de [Robotics Academy](https://jderobot.github.io/RoboticsAcademy/) en Docker
Con el objetivo de avanzar en un nuevo aporte para el TFG, con la idea de avanzar sobre un sistema de navegación, se ha propuesto estudiar sobre el **Control PID**.
Para ello, fue recomendado estudiar el ejercicio de **Follow Line** en **Robotics Academy**

### Configuración del entorno Docker
Para poder realizar dicho ejercicio, primero fue necesaria la instalación de Docker Engine, siguiendo los pasos de [instalación oficiales](https://docs.docker.com/engine/install/ubuntu/). 


### Robotics Academy
Tras la configuración del Docker, se pudo continuar con la instalación de Robotics Academy como se indicaba en la [guía](https://jderobot.github.io/RoboticsAcademy/user_guide/#installation), primero haciendo el **pull** tanto del Robotics Academy como de su **Database**:

```bash
docker pull jderobot/robotics-database:latest
docker pull jderobot/robotics-academy:latest
```
Después se inicio ambos contenedores para poder empezar con el ejercicio:

```bash
docker run --hostname my-postgres --name academy_db -d \
  -e POSTGRES_DB=academy_db \
  -e POSTGRES_USER=user-dev \
  -e POSTGRES_PASSWORD=robotics-academy-dev \
  -e POSTGRES_PORT=5432 \
  -p 5432:5432 \
  jderobot/robotics-database:latest
```

```bash
docker run --rm -it $(nvidia-smi >/dev/null 2>&1 && echo "--gpus all" || echo "") \
  --device /dev/dri \
  -p 6080:6080 -p 1108:1108 -p 7163:7163 -p 7164:7164 \
  --link academy_db \
  jderobot/robotics-academy:latest
```

El contenedor inicia un servidor Django en http://localhost:7164/, donde pueden ejecutarse los ejercicios desde el navegador.
Se confirmó el correcto funcionamiento de la base de datos (academy_db) y del entorno web de simulación.

## Ejercicio: [Follow Line](https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/follow_line/)

El objetivo de este ejercicio es diseñar un controlador visual que siga una línea roja en el suelo utilizando la cámara del vehículo.
Para ello se desarrolló un script basado en OpenCV y un control PID simple.
Primero se estudiaron algunas guías recomendadas por el ejercicio para la realización de la [detección de color](https://pyimagesearch.com/2014/08/04/opencv-python-color-detection/) de la línea, el calculo del centro mediante de la línea mediante el uso de [momentos geométricos](https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html) y una explicación extra para entender el funcionamiento de un [control PID](https://accautomation.ca/tag/pid-control-car-analogy/)

### Detección de la línea roja
Para aislar la línea en la imagen BGR se aplicó una máscara por color, dado que en el entorno simulado las condiciones de iluminación son estables:
```python
color_limit = ([0,0,150],[80,80,255])
lower = np.array(color_limit[0], dtype="uint8")
upper = np.array(color_limit[1], dtype="uint8")

mask = cv2.inRange(image, lower, upper)
output = cv2.bitwise_and(image, image, mask=mask)
```

### Cálculo del centro de la línea
Para determinar la posición de la línea se emplearon momentos geométricos:

```python
M = cv2.moments(mask)
if M["m00"] != 0:
    cX = int(M["m10"] / M["m00"])
    cY = int(M["m01"] / M["m00"])
else:
    cX, cY = 0, 0

```
De esta forma se obtiene el centroide de la zona roja detectada, que se compara con el centro ideal de la imagen (x_center).

### Control PID

El error se define como la diferencia horizontal entre el centro de la cámara y el centro de la línea detectada:

```python
    error = xcenter​−cX​​
```
Y se aplica un control PID clásico sobre la velocidad angular del vehículo:

```python
Kp = 0.002
Ki = 0.0
Kd = 0.001

integral += error
derivative = error - previous_error
w = Kp * error + Ki * integral + Kd * derivative
```
Para evitar oscilaciones bruscas, la velocidad lineal se ajusta dinámicamente según el giro:
```python
v_max, v_min = 4.0, 1.0
v = v_max - 2.0 * abs(w)
v = max(v, v_min)
```
### Resultados
<iframe width="560" height="315" src="https://www.youtube.com/embed/-GiVhvsDD9A?si=OQMoEzW-879-3tzu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Observaciones
Después de la realización del ejercicio de Robotics Academy y el previo estudio del control PID, el objetivo de la proxima semana será implementar dicho ejercicio en el simulador CARLA en el nuevo mapa que se está creando sobre un pinar.
