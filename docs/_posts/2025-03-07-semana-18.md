---
title: "Semana 18: Adici칩n de ruido y p칠rdidas al LiDAR sem치ntico"
excerpt_separator: "<!--more-->"
categories:
  - Blog
tags:
  - CARLA
  - Unreal
  - PythonAPI
  - LiDar
---

## LiDAR sem치ntico
Debido a que el LiDAR sem치ntico no introduce ni ruido ni p칠rdidas, a diferencia del LiDAR est치ndar, no se consiguen datos del todo realistas. Para solucionar esto, se ha decidido a침adir ruido y p칠rdidas manualmente en el c칩digo `o3d-semanticLidarViz-manual-segmentation.py`.

## `o3d-semanticLidarViz-manual-segmentation-noiseDrop.py`
Para a침adir ruido gaussiano y p칠rdidas, se han implementado dos funciones y se ha tenido que modificar la funci칩n `lidar_callback`:

### Modificaciones `lidar_callback`
```python
def lidar_callback(lidar_data, point_cloud, frame, 
                                noise_std=0.1, 
                                attenuation_coefficient=0.1, 
                                output_dir = 'dataset/lidar'):

    data = np.copy(np.frombuffer(lidar_data.raw_data, dtype=np.dtype('f4')))
    data = np.reshape(data, (int(data.shape[0] / 6), 6))  # Ahora cada fila tiene 6 valores

    # Reflejar los datos en el eje X para mantener coherencia con el sistema de coordenadas de CARLA
    data[:, 0] = -data[:, 0]

    # Extraer las coordenadas XYZ y los valores de intensidad
    points = data[:, :3]

    # Extraer etiquetas sem치nticas
    semantic_tags = data[:, 5].view(np.uint32)  # Ver datos como enteros
    
    # Calculamos la distancia de cada punto al sensor (suponiendo que el sensor est치 en el origen)
    distances = np.linalg.norm(points, axis=1)  # Distancia euclidiana

    # Calculamos la intensidad para cada punto utilizando la f칩rmula I = e^(-a * d)
    intensities = np.exp(-attenuation_coefficient * distances)

    # Aplicar ruido a los puntos
    points = add_noise_to_lidar(points, noise_std)

    # Aplicar p칠rdidas de puntos seg칰n las reglas del LiDAR
    points, semantic_tags = drop_points(points, semantic_tags, intensities)

    # Asignar colores seg칰n etiquetas
    colors = np.array([get_color_from_semantic(tag) for tag in semantic_tags]) / 255.0  # Normalizar a [0,1]

    # Asignar los datos modificados a la nube de puntos
    point_cloud.points = o3d.utility.Vector3dVector(points)  # Nube de puntos (Nx3).
    point_cloud.colors = o3d.utility.Vector3dVector(colors) # Colores RGB normalizados (Nx3)

    # Guardar las etiquetas sem치nticas en el campo "normals"
    point_cloud.normals = o3d.utility.Vector3dVector(np.c_[semantic_tags, semantic_tags, semantic_tags])

    # 游늭 Guardar el point cloud cada 20 frames
    # Crear la carpeta de salida si no existe
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    if frame % 20 == 0:
        filename = os.path.join(output_dir, f"lidar_points_{frame:04d}.ply")
        print(f"Guardando archivo {filename}...")
        o3d.io.write_point_cloud(filename, point_cloud)
```
Se a침adieron dos par치metros de entrada:
- noise_std: float - Desviaci칩n est치ndar del ruido Gaussiano que se aplica a las coordenadas XYZ de cada punto de la nube de puntos. Este par치metro introduce variabilidad en las mediciones, simulando errores de medici칩n t칤picos en sensores del mundo real.
- attenuation_coefficient: float - Coeficiente de atenuaci칩n utilizado para calcular la intensidad de cada punto en funci칩n de su distancia desde el sensor.

C치lculo de la Intensidad:
Debido a que en el LiDAR sem치ntico no calcula la intensidad de los puntos por defecto,  se ha decidido calcularla manualmente utilizando la siguiente f칩rmula, que se usa para el LiDAR est치ndar: I = e^(-a * d), donde:
- I es la intensidad.
- a es el coeficiente de atenuaci칩n.
- d es la distancia desde el sensor al punto.

Primero, calculamos la distancia de cada punto desde el sensor usando la norma euclidiana de sus coordenadas con: np.linalg.norm(points, axis=1)
Luego, aplicamos la f칩rmula de atenuaci칩n a esas distancias para calcular la intensidad de cada punto. Esto simula la p칠rdida de se침al a medida que los puntos est치n m치s alejados del sensor.

### Funci칩n `add_noise_to_lidar`
```python
def add_noise_to_lidar(points, std_dev):
    noise = np.random.normal(0, std_dev, points.shape)  # Ruido Gaussiano
    noisy_points = points + noise
    return noisy_points
```

Esta funci칩n recibe los siguientes par치metros de entrada:
- points: np.array (N, 3) - Coordenadas XYZ del LiDAR sem치ntico
- std_dev: float - Desviaci칩n est치ndar del ruido
Y devuelve:
- noisy_points: np.array (N, 3) - Nube de puntos con el ruido a침adido

Para a침adir el ruido, primero se genera un array del mismo tama침o que la cantidad de puntos que se detectan en el sensor LiDar, con muestras aleatorias extra칤das de una distribuci칩n normal (Gaussiana). Estos valores aleatorios se suman a las coordenadas de los puntos originales, lo que introduce el ruido en los puntos del LiDAR.

### Funci칩n `drop_points`
```python

    num_points = points.shape[0]

    # M치scara de eliminaci칩n aleatoria
    mask_drop_random = np.random.rand(num_points) < drop_rate

    # Restaurar puntos con alta intensidad (> intensity_limit)
    mask_keep_high_intensity = intensities > intensity_limit
    mask_drop_random[mask_keep_high_intensity] = False  # No eliminamos estos puntos

    # Verificar cu치ntos puntos tienen intensidad muy baja
    num_low_intensity = np.sum(intensities < low_intensity_threshold)
    print(f"Cantidad de puntos con intensidad menor a {low_intensity_threshold}: {num_low_intensity}")

    # M치scara para eliminar puntos con intensidad baja (por debajo del umbral)
    mask_drop_low_intensity = (intensities < low_intensity_threshold) & (np.random.rand(num_points) < zero_intensity_drop)
    
    # Combinamos todas las eliminaciones
    final_mask = ~mask_drop_random & ~mask_drop_low_intensity

    return points[final_mask],semantic_tags[final_mask]

```
Esta funci칩n recibe los siguientes par치metros de entrada:
- points: np.array (N, 3) - Coordenadas XYZ del LiDAR (sin informaci칩n adicional como colores o etiquetas).
- semantic_tags: np.array (N,) - Etiquetas sem치nticas de cada punto.
- intensities: np.array (N,) - Intensidades de los puntos.
- drop_rate: float - Probabilidad de eliminar un punto de forma aleatoria.
- intensity_limit: float - Umbral por encima del cual no se eliminan puntos (protecci칩n de puntos con alta intensidad).
- zero_intensity_drop: float - Probabilidad de eliminar puntos con intensidad cero.
- low_intensity_threshold: float - Umbral bajo de intensidad a partir del cual se eliminan los puntos.

Y devuelve:
-np.array (M, 3) - Nube de puntos con menos puntos
-np.array (M,) - Etiquetas sem치nticas filtradas


El objetivo de esta funci칩n es simular las p칠rdidas de puntos con la misma l칩gica que el LiDAR est치ndar:

- Eliminaci칩n Aleatoria: se crea una m치scara de eliminaci칩n aleaotoria, donde cada punto tiene una probabilidad (drop_rate) de ser eliminado. A cada punto de la nube se le asigna un n칰mero aleatorio del 0 al 1, y aquellos que tengan un n칰mero inferior a la m치scara ser치n descartados.

- Preservaci칩n de Puntos con Alta Intensidad: se crea una m치scara que recupera los puntos que tengan una intensidad mayor al umbral establecido. Esto se realiza para simular un entorno real, ya que estos puntos generalmente son los m치s cercanos y mejor reflejados, y por lo tanto son menos propensos a perderse.

- Eliminaci칩n de Puntos con Baja Intensidad: se aplica un umbral de baja intensidad para eliminar de manera aleatoria los puntos con una intensidad inferior a este, ya que normalmente son puntos muy alejados o peor reflejados, y por lo tanto son m치s propensos a perderse. Seg칰n la documentaci칩n de CARLA, el LiDAR est치ndar aplica esto para puntos con intensidad 0, pero como no se detectaban puntos con esa intensidad tras usar la f칩rmula, se decidi칩 eliminar los puntos con baja intensidad.

- Combinaci칩n de M치scaras: Las m치scaras de eliminaci칩n aleatoria y de eliminaci칩n por baja intensidad se combinan en una m치scara final (final_mask) que identifica los puntos que deben ser retenidos. Es decir, aquellos puntos que no cumplan con las condiciones de eliminaci칩n permanecen en la nube de puntos. Dicha m치scara se aplica al array de puntos y de etiquetas sem치nticas.

## Comparaci칩n del LiDAR sem치ntico con ruido y p칠rdidas
<iframe width="560" height="315" src="https://www.youtube.com/embed/145TTJrAU-Y?si=-9JUsJbENrNOI48M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Problemas
Se plante칩 la posibilidad de aplicar las funciones de ruido y p칠rdidas de puntos antes de la etiquetaci칩n de los puntos,con el objetivo de simular de manera m치s realista el comportamiento del LiDAR, y observar com칩 se generan errores en la etiquetaci칩n. Sin embargo, se encontr칩 que esto no es posible debido a que el LiDAR sem치ntico de CARLA proporciona las etiquetas sem치nticas directamente con los puntos. Esto implica que las etiquetas de los objetos ya est치n asignadas antes de que podamos aplicar las modificaciones. Por lo que se hace imposible aplicar ruido o p칠rdidas antes de la etiquetaci칩n sin modificar el c칩digo fuente de CARLA.
